// ==UserScript==
// @name         Zeus V3 Reaction Tracer Pro
// @namespace    http://tampermonkey.net/
// @version      3.17
// @description  Beautiful trigger & reaction tracer - Alt+7 - Nice grid UI
// @author       Debug Helper
// @match        http://localhost:*/*
// @match        https://localhost:*/*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    const script = document.createElement('script');
    script.textContent = `
    (function() {
        let tracerWindow = null;
        let isPaused = false;
        const hookedActors = new Set();
        const triggerData = new Map();
        const triggerFlow = [];
        let selectedTrigger = null;
        let isInitialized = false;
        let currentView = 'triggers';
        let expandedCategories = new Set(['reels', 'custom', 'actors', 'mini-games']);
        let expandedReceiverSections = new Set(['reels', 'symbols', 'cells', 'minigames', 'other']);
        const MAX_FLOW = 100;

        let highlightedActorName = null;
        let highlightOverlay = null;
        let pixiApp = null;
        let cachedReelBounds = null;
        let reelBoundsCacheTime = 0;

        const TRIGGER_PATTERNS = {
            'BeforeReelCellAttachSymbol': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'AfterReelCellAttachSymbol': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'BeforeReelCellDetachSymbol': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'SetReelSpinState': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'OnReelStopSpinning': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'OnReelStartSpinning': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'OnFirstReelStartSpinning': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'OnAllReelsStopSpinning': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'OnAllReelsStartSpinning': { category: 'reels', icon: 'üé∞', source: 'ActorTriggers.Reels' },
            'OnWinningsPresentationStart': { category: 'reels', icon: 'üèÜ', source: 'ActorTriggers.Reels' },
            'OnWinningsPresentation': { category: 'reels', icon: 'üèÜ', source: 'ActorTriggers.Reels' },
            'OnWinningsPresentationEnd': { category: 'reels', icon: 'üèÜ', source: 'ActorTriggers.Reels' },
            'OnIdle': { category: 'mini-games', icon: 'üéÆ', source: 'ActorTriggers.MiniGames' },
            'OnReceiveServerPlayGameResponse': { category: 'mini-games', icon: 'üéÆ', source: 'ActorTriggers.MiniGames' },
            'OnTransitionCurrentMiniGameToFutureMiniGame': { category: 'mini-games', icon: 'üéÆ', source: 'ActorTriggers.MiniGames' },
            'AddedToActorAsChild': { category: 'actors', icon: 'üë§', source: 'ActorTriggers.Actors' },
            'RemovedFromParentActor': { category: 'actors', icon: 'üë§', source: 'ActorTriggers.Actors' },
        };

        const CATEGORIES = {
            'reels': { name: 'Reels', icon: 'üé∞', color: '#f59e0b' },
            'mini-games': { name: 'Mini Games', icon: 'üéÆ', color: '#8b5cf6' },
            'actors': { name: 'Actors', icon: 'üë§', color: '#3b82f6' },
            'custom': { name: 'Custom', icon: '‚ö°', color: '#10b981' },
            'other': { name: 'Other', icon: 'üì¶', color: '#6b7280' }
        };

        function getPixiApp() {
            if (pixiApp) return pixiApp;
            if (window.__PIXI_APP__) { pixiApp = window.__PIXI_APP__; return pixiApp; }
            if (window.ZeusPlay?.pixiApp) { pixiApp = window.ZeusPlay.pixiApp; return pixiApp; }
            for (const key of Object.keys(window)) {
                const val = window[key];
                if (val && val.stage && val.renderer && typeof val.render === 'function') {
                    pixiApp = val; return pixiApp;
                }
            }
            return null;
        }

        function findActorInRegistry(name) {
            const registry = window.ZeusPlay?.actors?.actorsRegistry;
            if (!registry) return null;
            const match = name.match(/^([^\\[]+)(\\[(\\d+)\\])?$/);
            if (!match) return null;
            const baseName = match[1], index = match[3] !== undefined ? parseInt(match[3]) : 0;
            const store = registry.get(baseName);
            if (!store) return null;
            return (store._actors || store.actors || [])[index] || null;
        }

        function findParentCellLabel(actor) {
            if (!actor) return null;
            let current = actor.graphicContainer?.graphic || actor, depth = 0;
            while (current && depth < 20) {
                const label = current.label || current.name || '';
                if (/^Cell-\\d+-\\d+-\\d+$/i.test(label)) return label;
                current = current.parent; depth++;
            }
            return null;
        }

        function getReelAreaBounds() {
            const now = Date.now();
            if (cachedReelBounds && now - reelBoundsCacheTime < 500) return cachedReelBounds;
            const app = getPixiApp();
            if (!app?.stage) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            function findVisibleCells(node) {
                if (!node.worldVisible) return;
                const label = node.label || node.name || '';
                if (/^Cell-\\d+-\\d+-\\d+$/i.test(label)) {
                    try {
                        const bounds = node.getBounds();
                        if (bounds && bounds.width > 0) {
                            minX = Math.min(minX, bounds.x); minY = Math.min(minY, bounds.y);
                            maxX = Math.max(maxX, bounds.x + bounds.width); maxY = Math.max(maxY, bounds.y + bounds.height);
                        }
                    } catch (e) {}
                }
                if (node.children) for (const child of node.children) findVisibleCells(child);
            }
            findVisibleCells(app.stage);
            if (minX === Infinity) return null;
            cachedReelBounds = { x: minX - 20, y: minY - 20, right: maxX + 20, bottom: maxY + 20 };
            reelBoundsCacheTime = now;
            return cachedReelBounds;
        }

        function getActorBounds(actor) {
            const obj = actor?.graphicContainer?.graphic || actor;
            if (!obj || typeof obj.getBounds !== 'function') return null;
            try { const b = obj.getBounds(); if (b && (b.width > 0 || b.height > 0)) return b; } catch (e) {}
            return null;
        }

        function isInReelArea(bounds) {
            const rb = getReelAreaBounds();
            if (!rb || !bounds) return false;
            const cx = bounds.x + bounds.width / 2, cy = bounds.y + bounds.height / 2;
            return cx >= rb.x && cx <= rb.right && cy >= rb.y && cy <= rb.bottom;
        }

        function getActorVisibilityInfo(name, type) {
            const actor = findActorInRegistry(name);
            if (!actor) return { found: false, onScreen: false, parentCell: null };
            const obj = actor.graphicContainer?.graphic || actor;
            if (!obj) return { found: true, onScreen: false, parentCell: null };
            const worldVisible = obj.worldVisible ?? obj.visible ?? true;
            if (!worldVisible) return { found: true, onScreen: false, parentCell: null };
            const bounds = getActorBounds(actor);
            let parentCell = type === 'symbol' ? findParentCellLabel(actor) : null;
            return { found: true, onScreen: bounds ? isInReelArea(bounds) : false, parentCell };
        }

        function parseCellLabel(cellLabel) {
            if (!cellLabel) return { mg: 999, reel: 999, cell: 999 };
            const m = cellLabel.match(/^Cell-(\\d+)-(\\d+)-(\\d+)$/i);
            return m ? { mg: parseInt(m[1]), reel: parseInt(m[2]), cell: parseInt(m[3]) } : { mg: 999, reel: 999, cell: 999 };
        }

        function getSymbolDisplayName(name) {
            // sym:08[2] -> sym:08, scatter:201[0] -> scatter:201, wild[1] -> wild
            return name.replace(/\\[\\d+\\]$/, '');
        }

        function smartSortByCell(a, b) {
            const ca = parseCellLabel(a.parentCell), cb = parseCellLabel(b.parentCell);
            if (ca.mg !== cb.mg) return ca.mg - cb.mg;
            if (ca.reel !== cb.reel) return ca.reel - cb.reel;
            if (ca.cell !== cb.cell) return ca.cell - cb.cell;
            return a.name.localeCompare(b.name, undefined, { numeric: true });
        }

        function smartSortGeneric(a, b) {
            const parse = (n) => { const m = n.match(/^(.+?)\\[(\\d+)\\]$/); return m ? { base: m[1], idx: parseInt(m[2]) } : { base: n, idx: 0 }; };
            const pa = parse(a.name), pb = parse(b.name);
            return pa.base === pb.base ? pa.idx - pb.idx : pa.base.localeCompare(pb.base, undefined, { numeric: true });
        }

        function getTriggerInfo(triggerName) {
            const name = String(triggerName || '');
            if (TRIGGER_PATTERNS[name]) return { ...TRIGGER_PATTERNS[name], displayName: name };
            for (const [p, info] of Object.entries(TRIGGER_PATTERNS)) if (name.toLowerCase().includes(p.toLowerCase())) return { ...info, displayName: name };
            const nl = name.toLowerCase();
            let cat = 'other', icon = 'üì¶', src = 'Unknown';
            if (nl.includes('reel') || nl.includes('spin') || nl.includes('winning')) { cat = 'reels'; icon = 'üé∞'; src = 'ActorTriggers.Reels'; }
            else if (nl.includes('mini') || nl.includes('idle') || nl.includes('transition')) { cat = 'mini-games'; icon = 'üéÆ'; src = 'ActorTriggers.MiniGames'; }
            else if (nl.includes('actor') || nl.includes('child') || nl.includes('parent')) { cat = 'actors'; icon = 'üë§'; src = 'ActorTriggers.Actors'; }
            else if (nl.includes('custom-trigger')) { cat = 'custom'; icon = '‚ö°'; src = 'GameCustomTriggers'; }
            return { category: cat, icon, source: src, displayName: formatTriggerName(name) };
        }

        function formatTriggerName(t) {
            if (!t) return 'Unknown';
            return String(t).replace(/^custom-trigger-on-/, '').replace(/^on-/i, '').replace(/-/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        function getRelativeTime(ts) { const d = Date.now() - ts; return d < 1000 ? 'now' : d < 60000 ? Math.floor(d/1000) + 's' : Math.floor(d/60000) + 'm'; }

        function buildTriggerTree() {
            const tree = {};
            Object.keys(CATEGORIES).forEach(c => { tree[c] = { ...CATEGORIES[c], triggers: [] }; });
            triggerData.forEach((data, name) => {
                const info = getTriggerInfo(name), cat = info.category || 'other';
                if (!tree[cat]) tree[cat] = { ...CATEGORIES['other'], triggers: [] };
                tree[cat].triggers.push({ key: name, info, data });
            });
            Object.values(tree).forEach(c => c.triggers.sort((a, b) => b.data.lastTime - a.data.lastTime));
            return tree;
        }

        function parseReceiverType(name) {
            if (/^Reel-/i.test(name)) return 'reel';
            if (/^(sym|scatter|wild)/i.test(name)) return 'symbol';
            if (/^mg:/i.test(name)) return 'minigame';
            if (/^Cell-/i.test(name)) return 'cell';
            return 'other';
        }

        function categorizeReceivers(receivers) {
            const result = { reels: { onScreen: [], offScreen: [] }, symbols: { onScreen: [], offScreen: [] }, cells: { onScreen: [], offScreen: [] }, minigames: { onScreen: [], offScreen: [] }, other: { onScreen: [], offScreen: [] } };
            cachedReelBounds = null;
            receivers.forEach(name => {
                const type = parseReceiverType(name), vis = getActorVisibilityInfo(name, type);
                let cat;
                switch (type) { case 'reel': cat = result.reels; break; case 'symbol': cat = result.symbols; break; case 'cell': cat = result.cells; break; case 'minigame': cat = result.minigames; break; default: cat = result.other; }
                (vis.onScreen ? cat.onScreen : cat.offScreen).push({ name, ...vis });
            });
            result.symbols.onScreen.sort(smartSortByCell); result.symbols.offScreen.sort(smartSortByCell);
            result.cells.onScreen.sort((a,b) => { const ca = parseCellLabel(a.name), cb = parseCellLabel(b.name); return ca.mg !== cb.mg ? ca.mg - cb.mg : ca.reel !== cb.reel ? ca.reel - cb.reel : ca.cell - cb.cell; });
            result.cells.offScreen.sort((a,b) => { const ca = parseCellLabel(a.name), cb = parseCellLabel(b.name); return ca.mg !== cb.mg ? ca.mg - cb.mg : ca.reel !== cb.reel ? ca.reel - cb.reel : ca.cell - cb.cell; });
            [result.reels, result.other, result.minigames].forEach(r => { r.onScreen.sort(smartSortGeneric); r.offScreen.sort(smartSortGeneric); });
            return result;
        }

        function createHighlightOverlay() {
            if (highlightOverlay) return highlightOverlay;
            const div = document.createElement('div');
            div.id = '__rt_highlight__';
            Object.assign(div.style, { position: 'fixed', border: '3px solid #a855f7', background: 'rgba(168,85,247,0.2)', boxShadow: '0 0 20px rgba(168,85,247,0.5)', pointerEvents: 'none', zIndex: '2147483645', display: 'none', borderRadius: '8px' });
            const label = document.createElement('div');
            Object.assign(label.style, { position: 'absolute', bottom: '100%', left: '-3px', background: 'linear-gradient(135deg,#a855f7,#7c3aed)', color: '#fff', padding: '4px 10px', fontSize: '11px', fontWeight: 'bold', whiteSpace: 'nowrap', borderRadius: '4px 4px 0 0' });
            div.appendChild(label); document.body.appendChild(div);
            highlightOverlay = div; return div;
        }

        function clearHighlight() { if (highlightOverlay) highlightOverlay.style.display = 'none'; highlightedActorName = null; }

        function highlightActor(name) {
            const actor = findActorInRegistry(name);
            if (!actor) { clearHighlight(); return false; }
            highlightedActorName = name;
            const bounds = getActorBounds(actor);
            if (!bounds) { clearHighlight(); return false; }
            const canvas = document.querySelector('canvas');
            if (!canvas) { clearHighlight(); return false; }
            const rect = canvas.getBoundingClientRect(), app = getPixiApp();
            const sx = rect.width / (app?.renderer?.width || canvas.width), sy = rect.height / (app?.renderer?.height || canvas.height);
            const overlay = createHighlightOverlay();
            Object.assign(overlay.style, { left: (rect.left + bounds.x * sx) + 'px', top: (rect.top + bounds.y * sy) + 'px', width: (bounds.width * sx) + 'px', height: (bounds.height * sy) + 'px', display: 'block' });
            overlay.querySelector('div').textContent = name;
            return true;
        }

        function createTracerWindow() {
            if (tracerWindow && !tracerWindow.closed) { tracerWindow.focus(); return; }
            tracerWindow = window.open('', 'ReactionTracer', 'width=1200,height=900,left=100,top=50');
            tracerWindow.document.write(\`<!DOCTYPE html>
<html>
<head>
    <title>‚ö° Reaction Tracer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap');
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; }
        body { font-family: 'Inter', sans-serif; font-size: 13px; background: #0f0a1a; color: #e2e8f0; display: flex; flex-direction: column; }

        .header { padding: 10px 16px; background: linear-gradient(180deg, #1a1025, #150d20); border-bottom: 1px solid #2d2040; display: flex; gap: 12px; align-items: center; }
        .brand { display: flex; align-items: center; gap: 8px; }
        .logo { font-size: 22px; }
        .title { font-weight: 700; font-size: 16px; color: #a78bfa; }
        .status { padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; background: #7c3aed; color: #fff; }
        .status.paused { background: #dc2626; }
        .tabs { display: flex; background: #1e1530; border-radius: 8px; padding: 3px; }
        .tab { background: none; border: none; color: #9ca3af; padding: 6px 14px; cursor: pointer; font: inherit; font-size: 12px; border-radius: 6px; transition: all 0.15s; }
        .tab:hover { color: #fff; }
        .tab.active { background: #7c3aed; color: #fff; }
        .search { background: #1e1530; border: 1px solid #2d2040; color: #fff; padding: 6px 12px; border-radius: 8px; width: 160px; font: inherit; font-size: 12px; }
        .search:focus { outline: none; border-color: #7c3aed; }
        .btn { background: #1e1530; color: #e2e8f0; border: 1px solid #2d2040; border-radius: 8px; padding: 6px 14px; cursor: pointer; font: inherit; font-size: 12px; transition: all 0.15s; }
        .btn:hover { background: #2d2040; }
        .btn.danger { color: #f87171; border-color: #7f1d1d40; }
        .btn.danger:hover { background: #7f1d1d40; }

        .main { flex: 1; display: flex; overflow: hidden; }
        .left { width: 260px; background: #150d20; border-right: 1px solid #2d2040; display: flex; flex-direction: column; }
        .left-header { padding: 10px 12px; background: #1a1025; border-bottom: 1px solid #2d2040; font-size: 11px; font-weight: 600; color: #9ca3af; text-transform: uppercase; display: flex; justify-content: space-between; letter-spacing: 0.5px; }
        .count-badge { background: #7c3aed; color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 10px; }
        .tree { flex: 1; overflow-y: auto; padding: 6px 0; }
        .tree::-webkit-scrollbar { width: 6px; }
        .tree::-webkit-scrollbar-thumb { background: #2d2040; border-radius: 3px; }

        .cat { margin-bottom: 2px; }
        .cat-header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; cursor: pointer; border-left: 3px solid transparent; transition: all 0.15s; }
        .cat-header:hover { background: #1e1530; }
        .cat-chevron { font-size: 10px; color: #6b7280; transition: transform 0.15s; }
        .cat.open > .cat-header .cat-chevron { transform: rotate(90deg); }
        .cat-icon { font-size: 14px; }
        .cat-name { flex: 1; font-size: 12px; font-weight: 600; }
        .cat-count { font-size: 10px; color: #6b7280; }
        .cat-items { display: none; }
        .cat.open > .cat-items { display: block; }

        .trig { display: flex; align-items: center; gap: 6px; padding: 6px 12px 6px 28px; cursor: pointer; border-left: 3px solid transparent; transition: all 0.15s; }
        .trig:hover { background: #1e1530; }
        .trig.sel { background: #2e1a4a; border-left-color: #7c3aed; }
        .trig-name { flex: 1; font-size: 11px; color: #d1d5db; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .trig-cnt { font-size: 9px; color: #6b7280; background: #1e1530; padding: 2px 6px; border-radius: 8px; }

        .right { flex: 1; display: flex; flex-direction: column; background: #0f0a1a; overflow: hidden; }
        .detail-head { padding: 14px 16px; background: #150d20; border-bottom: 1px solid #2d2040; }
        .detail-title { font-size: 16px; font-weight: 700; color: #fff; margin-bottom: 8px; display: flex; align-items: center; gap: 10px; }
        .detail-meta { display: flex; gap: 8px; }
        .meta-tag { background: #1e1530; padding: 4px 10px; border-radius: 6px; font-size: 11px; color: #a78bfa; }

        .detail-body { flex: 1; overflow-y: auto; padding: 16px; }
        .detail-body::-webkit-scrollbar { width: 6px; }
        .detail-body::-webkit-scrollbar-thumb { background: #2d2040; border-radius: 3px; }

        .sec { background: #150d20; border: 1px solid #2d2040; border-radius: 10px; margin-bottom: 12px; }
        .sec-head { padding: 10px 14px; background: #1a1025; font-size: 11px; font-weight: 600; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #2d2040; border-radius: 10px 10px 0 0; }
        .sec-body { padding: 14px; }

        .summary-bar { display: flex; gap: 20px; padding: 10px 14px; background: #1a1025; border-radius: 8px; margin-bottom: 14px; font-size: 12px; }
        .summary-item { display: flex; align-items: center; gap: 6px; }
        .summary-dot { width: 10px; height: 10px; border-radius: 50%; }
        .summary-dot.on { background: #22c55e; box-shadow: 0 0 8px #22c55e60; }
        .summary-dot.off { background: #6b7280; }
        .summary-label { color: #9ca3af; }
        .summary-value { font-weight: 700; }
        .summary-value.on { color: #86efac; }
        .summary-value.off { color: #9ca3af; }

        .recv-category { margin-bottom: 10px; border: 1px solid #2d2040; border-radius: 8px; overflow: hidden; }
        .recv-cat-header { display: flex; align-items: center; gap: 8px; padding: 10px 14px; background: #1a1025; cursor: pointer; transition: all 0.15s; }
        .recv-cat-header:hover { background: #1e1530; }
        .recv-cat-chevron { font-size: 10px; color: #6b7280; transition: transform 0.15s; }
        .recv-category.open > .recv-cat-header .recv-cat-chevron { transform: rotate(90deg); }
        .recv-cat-icon { font-size: 16px; }
        .recv-cat-name { flex: 1; font-size: 13px; font-weight: 600; }
        .recv-cat-counts { display: flex; gap: 6px; }
        .recv-cnt { font-size: 10px; padding: 3px 8px; border-radius: 10px; font-weight: 600; }
        .recv-cnt.on { background: #166534; color: #86efac; }
        .recv-cnt.off { background: #374151; color: #9ca3af; }
        .recv-cat-body { display: none; padding: 12px; background: #0d0815; }
        .recv-category.open > .recv-cat-body { display: block; }

        /* Beautiful Grid */
        .grid-container { margin-bottom: 10px; }
        .grid-table { display: grid; gap: 3px; background: #12101a; border-radius: 8px; padding: 6px; }
        .grid-header { font-size: 11px; color: #8b9aaf; text-align: center; padding: 8px 4px; font-weight: 600; background: #1a1530; border-radius: 4px; }
        .grid-cell {
            background: #1a1228;
            border-radius: 6px;
            padding: 6px;
            min-height: 44px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            justify-content: center;
            align-items: center;
            transition: all 0.15s;
        }
        .grid-cell.has-on { background: #0f1f1a; border: 1px solid #16513480; }

        .sym-chip {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            text-align: center;
        }
        .sym-chip.on {
            background: linear-gradient(135deg, #166534, #14532d);
            color: #86efac;
            border: 1px solid #22c55e;
            box-shadow: 0 2px 4px #00000040;
        }
        .sym-chip.off {
            background: #1e1530;
            color: #6b7280;
            border: 1px solid #2d2040;
            opacity: 0.5;
        }
        .sym-chip:hover {
            transform: scale(1.05);
            opacity: 1 !important;
            box-shadow: 0 4px 12px #00000060;
        }
        .sym-chip.highlighted {
            background: linear-gradient(135deg, #7c3aed, #5b21b6) !important;
            color: #f3e8ff !important;
            border-color: #a855f7 !important;
            opacity: 1 !important;
            box-shadow: 0 0 12px #a855f760;
        }

        .other-section { margin-top: 12px; padding-top: 12px; border-top: 1px solid #2d204060; }
        .other-title { font-size: 10px; color: #6b7280; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .other-chips { display: flex; flex-wrap: wrap; gap: 6px; }

        .recv-chip {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .recv-chip.on {
            background: linear-gradient(135deg, #166534, #14532d);
            color: #86efac;
            border: 1px solid #22c55e;
        }
        .recv-chip.off {
            background: #1e1530;
            color: #6b7280;
            border: 1px solid #2d2040;
            opacity: 0.5;
        }
        .recv-chip:hover { opacity: 1; transform: scale(1.02); }
        .recv-chip.highlighted {
            background: linear-gradient(135deg, #7c3aed, #5b21b6) !important;
            color: #f3e8ff !important;
            border-color: #a855f7 !important;
            opacity: 1 !important;
        }

        .state-grid { display: flex; flex-direction: column; gap: 6px; }
        .state-row { display: flex; background: #1e1530; border-radius: 6px; overflow: hidden; }
        .state-key { background: #2e1a4a; padding: 8px 12px; min-width: 100px; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #c4b5fd; }
        .state-val { padding: 8px 12px; flex: 1; font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #fbbf24; word-break: break-all; }

        .empty { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: #6b7280; }
        .empty-icon { font-size: 48px; margin-bottom: 16px; opacity: 0.5; }
        .empty-text { font-size: 14px; }

        .timeline { padding: 8px; }
        .tl-item { display: flex; gap: 10px; margin-bottom: 3px; }
        .tl-time { width: 36px; font-size: 10px; color: #6b7280; text-align: right; padding-top: 10px; font-family: 'JetBrains Mono', monospace; }
        .tl-line { width: 20px; display: flex; flex-direction: column; align-items: center; }
        .tl-dot { width: 10px; height: 10px; border-radius: 50%; margin-top: 12px; }
        .tl-conn { width: 2px; flex: 1; background: #2d2040; }
        .tl-item:last-child .tl-conn { display: none; }
        .tl-card { flex: 1; background: #150d20; border: 1px solid #2d2040; border-radius: 8px; padding: 10px 12px; }
        .tl-name { font-weight: 600; font-size: 12px; color: #c4b5fd; margin-bottom: 4px; }
        .tl-flow { font-size: 11px; color: #9ca3af; }
    </style>
</head>
<body>
    <div class="header">
        <div class="brand"><span class="logo">‚ö°</span><span class="title">Reaction Tracer</span></div>
        <span id="status" class="status">Recording</span>
        <div class="tabs">
            <button id="tabTrig" class="tab active">Triggers</button>
            <button id="tabFlow" class="tab">Timeline</button>
        </div>
        <input id="search" class="search" placeholder="Search...">
        <div style="flex:1"></div>
        <button id="btnPause" class="btn">‚è∏ Pause</button>
        <button id="btnClear" class="btn danger">Clear</button>
    </div>
    <div class="main">
        <div class="left" id="leftPanel">
            <div class="left-header"><span>Categories</span><span class="count-badge" id="totalCount">0</span></div>
            <div class="tree" id="tree"></div>
        </div>
        <div class="right" id="rightPanel">
            <div id="detailHead" class="detail-head" style="display:none"></div>
            <div class="detail-body" id="detailBody">
                <div class="empty"><div class="empty-icon">‚ö°</div><div class="empty-text">Select a trigger to view details</div></div>
            </div>
        </div>
    </div>
</body>
</html>\`);
            tracerWindow.document.close();
            setTimeout(setupEvents, 100);
        }

        function setupEvents() {
            if (!tracerWindow || tracerWindow.closed) return;
            const doc = tracerWindow.document;
            doc.getElementById('btnPause').onclick = () => { isPaused = !isPaused; doc.getElementById('btnPause').textContent = isPaused ? '‚ñ∂ Resume' : '‚è∏ Pause'; doc.getElementById('status').textContent = isPaused ? 'Paused' : 'Recording'; doc.getElementById('status').className = 'status' + (isPaused ? ' paused' : ''); };
            doc.getElementById('btnClear').onclick = () => { triggerData.clear(); triggerFlow.length = 0; selectedTrigger = null; clearHighlight(); render(); };
            doc.getElementById('search').oninput = () => render();
            doc.getElementById('tabTrig').onclick = () => { currentView = 'triggers'; doc.getElementById('tabTrig').classList.add('active'); doc.getElementById('tabFlow').classList.remove('active'); doc.getElementById('leftPanel').style.display = 'flex'; render(); };
            doc.getElementById('tabFlow').onclick = () => { currentView = 'flow'; doc.getElementById('tabFlow').classList.add('active'); doc.getElementById('tabTrig').classList.remove('active'); doc.getElementById('leftPanel').style.display = 'none'; render(); };
            tracerWindow.onbeforeunload = () => clearHighlight();
        }

        function render() { if (currentView === 'flow') renderTimeline(); else { renderTree(); renderDetail(); } }

        function renderTree() {
            if (!tracerWindow || tracerWindow.closed) return;
            const doc = tracerWindow.document, container = doc.getElementById('tree'), search = doc.getElementById('search').value.toLowerCase(), tree = buildTriggerTree();
            let total = 0, html = '';
            Object.entries(tree).forEach(([catKey, cat]) => {
                const filtered = search ? cat.triggers.filter(t => t.info.displayName.toLowerCase().includes(search) || t.key.toLowerCase().includes(search)) : cat.triggers;
                if (filtered.length === 0) return;
                total += filtered.length;
                html += '<div class="cat ' + (expandedCategories.has(catKey) ? 'open' : '') + '" data-cat="' + catKey + '"><div class="cat-header" style="border-left-color:' + cat.color + '"><span class="cat-chevron">‚ñ∂</span><span class="cat-icon">' + cat.icon + '</span><span class="cat-name">' + cat.name + '</span><span class="cat-count">' + filtered.length + '</span></div><div class="cat-items">';
                filtered.forEach(t => { html += '<div class="trig ' + (selectedTrigger === t.key ? 'sel' : '') + '" data-key="' + t.key + '"><span class="trig-name" title="' + t.key + '">' + t.info.displayName + '</span><span class="trig-cnt">√ó' + t.data.count + '</span></div>'; });
                html += '</div></div>';
            });
            doc.getElementById('totalCount').textContent = total;
            container.innerHTML = html || '<div class="empty"><div class="empty-icon">‚è≥</div><div class="empty-text">Waiting for triggers...</div></div>';
            container.querySelectorAll('.cat-header').forEach(h => { h.onclick = () => { const cat = h.parentElement, key = cat.dataset.cat; cat.classList.toggle('open'); expandedCategories.has(key) ? expandedCategories.delete(key) : expandedCategories.add(key); }; });
            container.querySelectorAll('.trig').forEach(t => { t.onclick = (e) => { e.stopPropagation(); selectedTrigger = selectedTrigger === t.dataset.key ? null : t.dataset.key; clearHighlight(); renderTree(); renderDetail(); }; });
        }

        function renderGridSection(items) {
            const gridMap = {}, others = [];
            items.forEach(item => {
                const cell = parseCellLabel(item.parentCell || item.name);
                if (cell.reel < 900 && cell.cell < 900) {
                    const key = cell.reel + '-' + cell.cell;
                    if (!gridMap[key]) gridMap[key] = [];
                    gridMap[key].push(item);
                } else others.push(item);
            });

            let maxReel = 0, maxCell = 0;
            Object.keys(gridMap).forEach(k => { const [r, c] = k.split('-').map(Number); maxReel = Math.max(maxReel, r); maxCell = Math.max(maxCell, c); });

            if (maxReel === 0 && maxCell === 0 && Object.keys(gridMap).length === 0) return renderChipList(items);

            const cols = maxReel + 1, rows = maxCell + 1;
            let html = '<div class="grid-container"><div class="grid-table" style="grid-template-columns: 36px repeat(' + cols + ', 1fr);">';
            html += '<div class="grid-header"></div>';
            for (let r = 0; r < cols; r++) html += '<div class="grid-header">R' + r + '</div>';
            for (let c = 0; c < rows; c++) {
                html += '<div class="grid-header">C' + c + '</div>';
                for (let r = 0; r < cols; r++) {
                    const key = r + '-' + c, cellItems = gridMap[key] || [], hasOn = cellItems.some(i => i.onScreen);
                    html += '<div class="grid-cell' + (hasOn ? ' has-on' : '') + '">';
                    cellItems.forEach(item => {
                        const displayName = getSymbolDisplayName(item.name);
                        html += '<div class="sym-chip ' + (item.onScreen ? 'on' : 'off') + '" data-actor="' + item.name + '" title="' + item.name + '">' + displayName + '</div>';
                    });
                    html += '</div>';
                }
            }
            html += '</div>';
            if (others.length > 0) {
                html += '<div class="other-section"><div class="other-title">Other (' + others.length + ')</div><div class="other-chips">';
                others.forEach(item => { html += '<div class="recv-chip ' + (item.onScreen ? 'on' : 'off') + '" data-actor="' + item.name + '">' + item.name + '</div>'; });
                html += '</div></div>';
            }
            html += '</div>';
            return html;
        }

        function renderChipList(items) {
            if (items.length === 0) return '<div style="color:#6b7280;text-align:center;padding:12px;font-size:12px;">None</div>';
            let html = '<div class="other-chips">';
            items.forEach(item => { html += '<div class="recv-chip ' + (item.onScreen ? 'on' : 'off') + '" data-actor="' + item.name + '">' + item.name + '</div>'; });
            return html + '</div>';
        }

        function renderReceiverCategory(key, icon, name, data, isOpen, useGrid = false) {
            const total = data.onScreen.length + data.offScreen.length;
            if (total === 0) return '';
            const allItems = [...data.onScreen, ...data.offScreen];
            let html = '<div class="recv-category ' + (isOpen ? 'open' : '') + '" data-recv-cat="' + key + '"><div class="recv-cat-header"><span class="recv-cat-chevron">‚ñ∂</span><span class="recv-cat-icon">' + icon + '</span><span class="recv-cat-name">' + name + '</span><div class="recv-cat-counts">';
            if (data.onScreen.length > 0) html += '<span class="recv-cnt on">üëÅ ' + data.onScreen.length + '</span>';
            if (data.offScreen.length > 0) html += '<span class="recv-cnt off">‚óã ' + data.offScreen.length + '</span>';
            html += '</div></div><div class="recv-cat-body">' + (useGrid ? renderGridSection(allItems) : renderChipList(allItems)) + '</div></div>';
            return html;
        }

        function renderDetail() {
            if (!tracerWindow || tracerWindow.closed || currentView === 'flow') return;
            const doc = tracerWindow.document, head = doc.getElementById('detailHead'), body = doc.getElementById('detailBody');
            if (!selectedTrigger || !triggerData.has(selectedTrigger)) { head.style.display = 'none'; body.innerHTML = '<div class="empty"><div class="empty-icon">‚ö°</div><div class="empty-text">Select a trigger to view details</div></div>'; return; }

            const data = triggerData.get(selectedTrigger), info = getTriggerInfo(selectedTrigger);
            head.style.display = 'block';
            head.innerHTML = '<div class="detail-title">' + info.icon + ' ' + info.displayName + '</div><div class="detail-meta"><span class="meta-tag">' + info.source + '</span><span class="meta-tag">üî• ' + data.count + 'x</span></div>';

            const receivers = data.receivers || [], categorized = categorizeReceivers(receivers);
            let totalOn = 0, totalOff = 0;
            Object.values(categorized).forEach(cat => { totalOn += cat.onScreen.length; totalOff += cat.offScreen.length; });

            let html = '<div class="sec"><div class="sec-head">Receivers</div><div class="sec-body">';
            html += '<div class="summary-bar"><div class="summary-item"><div class="summary-dot on"></div><span class="summary-label">In Area:</span><span class="summary-value on">' + totalOn + '</span></div>';
            html += '<div class="summary-item"><div class="summary-dot off"></div><span class="summary-label">Outside:</span><span class="summary-value off">' + totalOff + '</span></div>';
            html += '<div class="summary-item"><span class="summary-label">Total:</span><span class="summary-value">' + receivers.length + '</span></div></div>';
            html += renderReceiverCategory('reels', 'üé°', 'Reel Actors', categorized.reels, expandedReceiverSections.has('reels'), false);
            html += renderReceiverCategory('symbols', 'üé≤', 'Symbol Actors', categorized.symbols, expandedReceiverSections.has('symbols'), true);
            html += renderReceiverCategory('cells', 'üìç', 'Cell Actors', categorized.cells, expandedReceiverSections.has('cells'), true);
            html += renderReceiverCategory('minigames', 'üéÆ', 'Mini Games', categorized.minigames, expandedReceiverSections.has('minigames'), false);
            html += renderReceiverCategory('other', 'üì¶', 'Other Actors', categorized.other, expandedReceiverSections.has('other'), false);
            if (receivers.length === 0) html = '<div class="sec"><div class="sec-head">Receivers</div><div class="sec-body" style="color:#6b7280;text-align:center;padding:20px;">Broadcast to all actors</div></div>';
            else html += '</div></div>';

            html += '<div class="sec"><div class="sec-head">State</div><div class="sec-body">';
            if (data.state && Object.keys(data.state).length > 0) {
                html += '<div class="state-grid">';
                Object.entries(data.state).forEach(([k,v]) => { html += '<div class="state-row"><div class="state-key">' + k + '</div><div class="state-val">' + JSON.stringify(v) + '</div></div>'; });
                html += '</div>';
            } else html += '<div style="color:#6b7280;text-align:center;font-size:12px;">No state data</div>';
            html += '</div></div>';

            body.innerHTML = html;
            body.querySelectorAll('.recv-cat-header').forEach(h => { h.onclick = () => { const cat = h.parentElement, key = cat.dataset.recvCat; cat.classList.toggle('open'); expandedReceiverSections.has(key) ? expandedReceiverSections.delete(key) : expandedReceiverSections.add(key); }; });
            body.querySelectorAll('[data-actor]').forEach(el => { el.onclick = (e) => { e.stopPropagation(); const name = el.dataset.actor; if (highlightedActorName === name) clearHighlight(); else highlightActor(name); body.querySelectorAll('[data-actor]').forEach(e => e.classList.toggle('highlighted', highlightedActorName === e.dataset.actor)); }; });
        }

        function renderTimeline() {
            if (!tracerWindow || tracerWindow.closed) return;
            const doc = tracerWindow.document, body = doc.getElementById('detailBody'), search = doc.getElementById('search').value.toLowerCase();
            doc.getElementById('detailHead').style.display = 'none';
            const filtered = triggerFlow.filter(f => !search || f.name.toLowerCase().includes(search));
            doc.getElementById('totalCount').textContent = filtered.length;
            if (filtered.length === 0) { body.innerHTML = '<div class="empty"><div class="empty-icon">üìú</div><div class="empty-text">No triggers recorded yet</div></div>'; return; }
            let html = '<div class="timeline">';
            filtered.slice(0, 50).forEach((f) => { const info = getTriggerInfo(f.name), catInfo = CATEGORIES[info.category] || CATEGORIES['other']; html += '<div class="tl-item"><div class="tl-time">' + getRelativeTime(f.time) + '</div><div class="tl-line"><div class="tl-dot" style="background:' + catInfo.color + '"></div><div class="tl-conn"></div></div><div class="tl-card"><div class="tl-name">' + info.icon + ' ' + info.displayName + '</div><div class="tl-flow">' + (f.sender || '?') + ' ‚Üí ' + (f.receivers?.length || 0) + ' actors</div></div></div>'; });
            body.innerHTML = html + '</div>';
        }

        function logTrigger(name, state, sender, receivers) {
            if (isPaused) return;
            const now = Date.now(), existing = triggerData.get(name);
            triggerData.set(name, { state, sender, receivers, lastTime: now, count: (existing?.count || 0) + 1 });
            triggerFlow.unshift({ name, state, sender, receivers, time: now });
            if (triggerFlow.length > MAX_FLOW) triggerFlow.length = MAX_FLOW;
            if (tracerWindow && !tracerWindow.closed) render();
        }

        function hookActor(actor, actorName) {
            if (!actor || typeof actor.exposeTrigger !== 'function' || hookedActors.has(actor)) return false;
            const original = actor.exposeTrigger.bind(actor);
            actor.exposeTrigger = function(trigger) {
                const name = trigger?.triggerName || trigger?.constructor?.triggerName || trigger?.name || 'unknown', state = trigger?.state || {}, registry = window.ZeusPlay?.actors?.actorsRegistry, receivers = [];
                if (registry) registry.forEach((store, n) => { (store._actors || store.actors || []).forEach((a, i) => { if (a !== actor) receivers.push((store._actors || store.actors).length > 1 ? n + '[' + i + ']' : n); }); });
                logTrigger(name, state, actorName, receivers.slice(0, 200));
                return original(trigger);
            };
            hookedActors.add(actor);
            return true;
        }

        function hookAllActors() {
            const registry = window.ZeusPlay?.actors?.actorsRegistry;
            if (!registry) return;
            registry.forEach((store, name) => { (store._actors || store.actors || []).forEach((actor, idx) => { hookActor(actor, (store._actors || store.actors).length > 1 ? name + '[' + idx + ']' : name); }); });
        }

        function init() { if (isInitialized) return; isInitialized = true; hookAllActors(); setInterval(hookAllActors, 2000); }

        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.key === '7') { e.preventDefault(); if (tracerWindow && !tracerWindow.closed) { tracerWindow.focus(); return; } if (!window.ZeusPlay?.actors?.actorsRegistry) return; init(); createTracerWindow(); }
        });

        console.log('[Reaction Tracer v3.17] ‚úÖ Alt+7');
    })();
    `;
    document.head.appendChild(script);
})();
